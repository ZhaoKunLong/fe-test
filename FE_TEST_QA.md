## 选择题

1. 下列哪个不是 JavaScript 的数据类型？ ( B )  
   A. String  
   B. Number  
   C. Boolean  
   D. Object

2. 下列哪个不是 CSS 的盒子模型？ ( C )  
   A. content-box  
   B. border-box  
   C. padding-box  
   D. margin-box

3. 下列哪个不是 Vue.js 的生命周期钩子函数？ ( C )  
   A. created  
   B. mounted  
   C. updated  
   D. destroyed

4. 下列哪个不是 HTTP 请求方法？ ( D )  
   A. GET  
   B. POST  
   C. PUT  
   D. DELETE

5. 下列哪个不是 HTML 标签？ ( D )  
   A. div  
   B. span  
   C. p  
   D. js

6. 下列哪个不是 CSS 选择器？ ( D )  
   A. .class  
   B. #id  
   C. :hover  
   D. @media

7. 下列哪个不是 JavaScript 的循环语句？ ( D )  
   A. for  
   B. while  
   C. do-while  
   D. if-else

8. 下列哪个不是 JavaScript 的比较运算符？ ( D )  
   A. ==  
   B. !=  
   C. ===  
   D. <=>

9. 下列哪个不是 JavaScript 的逻辑运算符？ ( D )  
   A. &&  
   B. ||  
   C. !  
   D. &

10. 下列哪个不是 JavaScript 的函数声明方式？ ( D )  
    A. function foo() {}  
    B. const foo = function() {}  
    C. const foo = () => {}  
    D. new Function('a', 'b', 'return a + b')

11. 下列哪个不是 JavaScript 的内置对象？ ( D )  
    A. Math  
    B. Date  
    C. Array  
    D. Promise

12. 下列哪个不是 JavaScript 的原始值？ ( C )  
    A. null  
    B. undefined  
    C. NaN  
    D. Infinity

13. 下列哪个不是 Vue.js 的指令？ ( C )  
    A. v-if  
    B. v-for  
    C. v-switch  
    D. v-bind

14. 下列哪个不是 CSS 的定位属性？ ( D )  
    A. position  
    B. top  
    C. left  
    D. width

15. 下列哪个不是 JavaScript 的错误类型？ ( D )  
    A. SyntaxError  
    B. TypeError  
    C. ReferenceError  
    D. RangeError

16. 下列哪个不是 Vue.js 的组件通信方式？ ( D )  
    A. props  
    B. event bus  
    C. Vuex  
    D. $emit

17. 下列哪个不是 JavaScript 的面向对象编程特性？ ( D )  
    A. 封装  
    B. 继承  
    C. 多态  
    D. 并发

18. 下列哪个不是 CSS 的动画属性？ ( C )  
    A. animation-name  
    B. animation-duration  
    C. animation-color  
    D. animation-timing-function

19. 下列哪个不是 JavaScript 的异步编程方式？ ( D )  
    A. 回调函数  
    B. Promise  
    C. async/await  
    D. for 循环

20. 下列哪个不是 Vue.js 的路由模式？ ( C )  
    A. hash  
    B. history  
    C. memory  
    D. abstract

21. 下列哪个不是 JavaScript 的事件类型？ ( B )  
    A. click  
    B. hover  
    C. keydown  
    D. scroll

22. 下列哪个不是 CSS 的布局方式？ ( D )  
    A. flexbox  
    B. grid  
    C. table  
    D. float

23. 下列哪个不是 JavaScript 的模块化规范？ ( D )  
    A. CommonJS  
    B. AMD  
    C. ES6 Module  
    D. jQuery

24. 下列哪个不是 Vue.js 的指令修饰符？ ( D )  
    A. .prevent  
    B. .stop  
    C. .once  
    D. .delay

25. 下列哪个不是 JavaScript 的数组方法？ ( D )  
    A. push  
    B. pop  
    C. shift  
    D. slice

26. 下列哪个不是 CSS 的字体属性？ ( C )  
    A. font-size  
    B. font-weight  
    C. font-color  
    D. font-family

27. 下列哪个不是 JavaScript 的定时器函数？ ( C )  
    A. setTimeout  
    B. setInterval  
    C. setImmediate  
    D. requestAnimationFrame

28. 下列哪个不是 Vue.js 的计算属性特性？ ( D )  
    A. 缓存  
    B. 响应式  
    C. 计算  
    D. 懒加载

29. 下列哪个不是 JavaScript 的正则表达式元字符？ ( C )  
    A. ^  
    B. $  
    C. &  
    D. \

30. 下列哪个不是 CSS 的背景属性？ ( C )  
    A. background-color  
    B. background-image  
    C. background-position  
    D. background-size

31. 下列哪个不是 JavaScript 的解构赋值方式？ ( D )  
    A. 数组解构  
    B. 对象解构  
    C. 函数解构  
    D. 字符串解构

32. 下列哪个不是 Vue.js 的过渡动画？ ( D )  
    A. v-enter  
    B. v-leave  
    C. v-move  
    D. v-fade

33. 下列哪个不是 JavaScript 的字符串方法？ ( D )  
    A. indexOf  
    B. split  
    C. join  
    D. push

34. 下列哪个不是 CSS 的边框属性？ ( D )  
    A. border-width  
    B. border-style  
    C. border-color  
    D. border-radius

35. 下列哪个不是 JavaScript 的面向对象编程语言？ ( A )  
    A. Java  
    B. Python  
    C. C++  
    D. Ruby

36. 下列哪个不是 Vue.js 的指令修饰符？ ( D )  
    A. .prevent  
    B. .stop  
    C. .once  
    D. .delay

37. 下列哪个不是 JavaScript 的全局对象？ ( B )  
    A. window  
    B. document  
    C. navigator  
    D. console

38. 当设置 box-sizing 为 content-box 时，下面关于 CSS 布局的描述，不正确的是？ ( D )
    A. 块级元素实际占用的宽度与它的 width 属性有关  
    B. 块级元素实际占用的宽度与它的 border 属性有关  
    C. 块级元素实际占用的宽度与它的 padding 属性有关  
    D. 块级元素实际占用的宽度与它的 margin 属性有关

39. box-sizing 属性的默认值是什么？ ( A )
    A. content-box  
    B. border-box  
    C. padding-box  
    D. margin-box

40. 下列哪个属性不属于 CSS 的盒子模型？ ( D )  
    A. width  
    B. height  
    C. margin  
    D. color

---

## 简答题

- 请简述 Vue.js 的生命周期钩子函数？
  ```markdown
  In Vue.js, a lifecycle hook function is a special function that allows us to execute custom code at specific points during the lifecycle of a Vue component. These hooks provide opportunities to perform actions or manipulate data at various stages, such as before a component is created, mounted, updated, or destroyed. The lifecycle hooks enable developers to control the behavior of their components and integrate additional logic seamlessly.
  ```

Vue.js provides several lifecycle hooks that are invoked automatically during the component's lifecycle. Here is a brief description of some commonly used hooks:

1. beforeCreate: This hook is triggered before the component is created. At this point, data observation and event/watcher setup have not occurred.

2. created: The created hook is called immediately after the component is created. In this phase, the component's data, methods, computed properties, and watchers are set up. However, the component has not been mounted into the DOM yet.

3. beforeMount: This hook is executed right before the component is mounted to the DOM. It is useful for performing tasks that require access to the component's template or manipulating the DOM directly.

4. mounted: The mounted hook is called after the component has been inserted into the DOM. It is often used to fetch data from an API, set up event listeners, or perform other initialization tasks.

5. beforeUpdate: This hook is triggered when a reactive property within the component changes, but before the DOM is re-rendered. It allows you to perform necessary actions before the update takes place.

6. updated: The updated hook is called after the component has been re-rendered due to data changes. It is useful for interacting with the updated DOM or executing additional logic based on the changes.

7. beforeDestroy: This hook is invoked right before the component is destroyed and removed from the DOM. It can be used to clean up event listeners, timers, or other resources created during the component's lifecycle.

8. destroyed: The destroyed hook is called after the component has been destroyed. It allows you to perform any necessary cleanup or finalization tasks.

These lifecycle hooks provide developers with fine-grained control over the component's behavior and enable them to respond to specific events during its lifecycle. By leveraging these hooks effectively, Vue.js developers can create powerful and interactive applications with ease.

````
- 请简述Vue.js的组件化开发方式？
```markdown
The componentized development method in Vue.js revolves around breaking down our application's user interface into reusable and self-contained components. Each component represents a specific part of the UI, such as a button, form input, or even a more complex element like a navigation bar or a product list.

In Vue.js, components are created using the Vue.extend() method or by defining them as Single File Components (SFCs) with the .vue file extension. Components encapsulate their own logic, data, styles, and template, making them modular and independent. This approach promotes code reusability, maintainability, and easier collaboration among team members.

The key aspects of componentized development in Vue.js are as follows:

1. **Component Definition**: Components are defined using the Vue.extend() method or by creating .vue files that contain the component's template, script, and styles.

2. **Component Structure**: Each component typically consists of a template (HTML-based markup), a script (JavaScript code that defines the component's behavior and data), and optional styles (CSS or preprocessor code).

3. **Reusability**: Components are designed to be reusable. They can be instantiated multiple times throughout the application, allowing consistent UI elements to be used across different views and pages.

4. **Data Isolation**: Each component has its own data scope, meaning that the component's data is independent and does not interfere with other components. This ensures that changes to one component do not affect others unless explicitly passed as props.

5. **Component Communication**: Components can communicate with each other through props, events, and a centralized event bus. Props allow parent components to pass data down to child components, while events enable child components to emit events and notify parent components about certain actions or state changes.

6. **Lifecycle Hooks**: Vue.js provides various lifecycle hooks that allow you to execute custom code at specific stages of a component's lifecycle. These hooks enable you to perform initialization, cleanup, or other actions at the appropriate times.

7. **Component Composition**: Components can be composed hierarchically, with parent components encapsulating child components. This allows for a nested structure where smaller, more specialized components can be combined to create larger, more complex components or views.

By adopting the componentized development approach in Vue.js, developers can build applications that are easier to understand, maintain, and scale. It promotes code reusability, modularity, and separation of concerns, leading to more efficient and collaborative development processes.
````

- 请简述 CSS 中的盒模型是什么，以及它的应用场景。

  ```markdown
  The box model in CSS is a fundamental concept that defines how elements are structured and displayed on a webpage. It describes the properties and behavior of an element's content, padding, borders, and margins.
  ```

The box model consists of four main components: the content area, padding, border, and margin. The content area holds the actual content of the element, such as text or images. The padding is the space between the content and the element's border, providing a cushioning effect. The border surrounds the padding and content, defining a line or area. Finally, the margin is the space outside the element's border, creating a gap between adjacent elements or the container.

The box model is used in CSS to control the layout, spacing, and dimensions of elements on a webpage. It allows developers to adjust the positioning of elements, control the spacing between them, and create visually pleasing designs. By manipulating the properties of the box model, such as width, height, padding, border, and margin, developers can customize the appearance and behavior of elements to achieve desired layouts and styling effects.

The box model is used in various scenarios, including creating responsive layouts that adapt to different screen sizes, applying styles to elements by adjusting padding, border, or margin, resolving alignment issues between elements, and calculating element sizes for accurate placement. Understanding and effectively using the box model is essential for building well-structured and visually appealing web pages.

````

- 请简述 CSS 中的选择器有哪些，以及它们的优先级。

```markdown
In CSS (Cascading Style Sheets), selectors are used to target specific HTML elements and apply styles to them. Selectors define the criteria for selecting elements based on their tag names, class names, IDs, attributes, or their relationship with other elements in the HTML structure.

CSS selectors allow developers to target elements in different ways:

1. **Tag Selectors**: Select elements based on their HTML tag name, such as `p`, `div`, or `h1`. These selectors apply styles to all elements of the specified tag.

2. **Class Selectors**: Select elements based on their class attribute. The class selector is denoted with a dot (`.`) followed by the class name, such as `.my-class`. Multiple elements can share the same class, and the class selector allows targeting specific elements based on their class assignment.

3. **ID Selectors**: Select a unique element based on its ID attribute. The ID selector is denoted with a hash (`#`) followed by the ID name, such as `#my-id`. IDs must be unique within an HTML document, and the ID selector selects only one element.

4. **Attribute Selectors**: Select elements based on specific attributes or attribute values. For example, `[type="text"]` selects all elements with the attribute `type` set to `"text"`, and `[href^="https://"]` selects elements with `href` attribute values starting with `"https://"`.

5. **Pseudo-classes and Pseudo-elements**: Pseudo-classes select elements based on their state or position within the document structure. Examples include `:hover`, `:focus`, `:first-child`, and `:nth-child()`. Pseudo-elements target specific parts of an element, such as `::before` or `::after`.

CSS selectors have a specific order of precedence, known as specificity, which determines which styles are applied when multiple selectors target the same element. The general rules of specificity are as follows:

1. **ID Selector**: Carries the highest specificity weight. Styles applied through an ID selector override any other selector types.

2. **Class Selector, Attribute Selector, and Pseudo-class Selector**: These have a medium specificity weight and are ranked below ID selectors. If conflicting styles are applied, the one defined later in the stylesheet takes precedence.

3. **Tag Selector and Pseudo-element Selector**: These have the lowest specificity weight and are ranked below the previous selector types. If conflicting styles are applied, the one defined later in the stylesheet takes precedence.

In addition to specificity, the order of styles in the CSS file also matters. If conflicting styles have the same specificity, the one defined later in the stylesheet will override the earlier one.

Understanding selectors and their precedence is crucial for accurately targeting elements and controlling the application of styles in CSS.
````

- 请简述 CSS 中的浮动和清除浮动是什么，以及它们的应用场景。

  ```markdown
  In CSS, the `float` property is used to define the positioning of an element within its parent container. When an element is floated, it is removed from the normal flow of the document and positioned either to the left or right side of its container. Other content flows around the floated element.
  ```

Floats are commonly used for:

1. **Text Wrapping**: By floating an image or an element with text content, you can make the surrounding text flow around it, creating a visually appealing layout.

2. **Creating Multi-column Layouts**: Floats can be used to create multiple columns within a container, where each column is floated to the left or right.

3. **Building Grid-like Structures**: Floats can be employed to create grid-like structures by floating elements next to each other in a row-based or column-based manner.

However, when using floats, one important consideration is the need to clear them. When elements are floated, they are taken out of the normal document flow, which can lead to layout issues. Other elements may not position themselves correctly, resulting in overlapping or unintended layout inconsistencies.

To address this, the concept of "clearing floats" comes into play. Clearing a float means ensuring that elements following the floated element start below it, rather than alongside it. This prevents any unintended wrapping or overlapping of content.

CSS provides the `clear` property to clear floats. By applying `clear: left`, `clear: right`, or `clear: both` to an element, you can specify that it should appear below any floated elements on the left side, right side, or both sides, respectively.

Clearing floats is typically used in scenarios such as:

1. **Containing Floated Elements**: If a container element contains floated child elements, applying the appropriate clear property ensures that subsequent content appears below the floated elements, preventing layout issues.

2. **Creating Self-clearing Containers**: Clearing floats can be used to create self-clearing containers that automatically adjust their height to accommodate floated elements within them.

3. **Preventing Collapsing Parent Elements**: When parent elements only contain floated child elements, they might collapse and have a height of 0. Clearing the floats ensures that the parent element expands to contain its floated children.

Clearing floats is crucial for maintaining consistent and predictable layouts when using floats in CSS. It helps avoid unintended wrapping and overlapping of content and ensures proper positioning of subsequent elements in the document flow.

````

- 请简述 CSS 中的定位和层叠顺序是什么，以及它们的应用场景。

```markdown
In CSS (Cascading Style Sheets), positioning refers to the method of determining the placement and layout of elements on a webpage. CSS provides several positioning properties that allow developers to control how elements are positioned within their parent containers or in relation to other elements.

The positioning properties in CSS include:

1. **Static Positioning**: This is the default positioning behavior where elements follow the normal flow of the document. Static positioned elements are not affected by other positioning properties.

2. **Relative Positioning**: When an element is positioned relative, it is offset from its normal position based on the values specified for the `top`, `right`, `bottom`, or `left` properties. Relative positioning does not remove the element from the normal document flow, so it still affects the layout of surrounding elements.

3. **Absolute Positioning**: Absolute positioning allows elements to be positioned relative to their nearest positioned ancestor or the document's root element. It is removed from the normal document flow, and its position is determined by setting the `top`, `right`, `bottom`, or `left` properties. Other elements are not affected by the absolute positioned element.

4. **Fixed Positioning**: Fixed positioning positions an element relative to the viewport (the browser window). It remains in a fixed position even when the page is scrolled. Fixed positioned elements do not affect the layout of other elements.

5. **Sticky Positioning**: Sticky positioning is a hybrid of relative and fixed positioning. It behaves as relative positioning until the element reaches a specified threshold, at which point it becomes fixed and remains in that position even when scrolling.

The cascading order, often referred to as the cascade, is the mechanism that determines which styles are applied to an element when multiple style rules conflict. CSS follows a set of rules to determine the priority of conflicting styles, and the styles with higher specificity or later in the stylesheet generally take precedence.

The cascade in CSS follows the following order of precedence:

1. **Importance**: Styles with the `!important` declaration have the highest priority and override other styles. However, it is generally recommended to use `!important` sparingly to maintain a maintainable and manageable codebase.

2. **Specificity**: Styles with higher specificity take precedence over styles with lower specificity. Specificity is calculated based on the combination of selectors used to target an element.

3. **Source Order**: When conflicting styles have the same importance and specificity, the styles defined later in the stylesheet override the earlier ones. The last style rule encountered takes precedence.

Positioning and the cascade are used in CSS to control the layout, positioning, and visual appearance of elements on a webpage. By understanding and applying positioning properties, developers can precisely control where elements appear on the page and how they interact with other elements. The cascade ensures that conflicting styles are resolved in a predictable manner, allowing for consistent and maintainable stylesheets.
````

- 请简述 CSS 中的响应式设计是什么，以及它的应用场景。

  ```
  Responsive design is an approach in CSS (Cascading Style Sheets) that enables web pages to adapt and respond to different screen sizes, devices, and orientations. It involves designing and building websites in a way that ensures optimal viewing and usability across various devices, including desktops, laptops, tablets, and smartphones.
  ```

The goal of responsive design is to create a seamless user experience by adjusting the layout, content, and visual elements of a webpage based on the characteristics of the device being used. Instead of creating separate versions of a website for different devices, responsive design uses CSS techniques to dynamically adapt the presentation and behavior of the website to fit the available screen space.

Responsive design relies on several key principles and CSS features:

1. **Flexible Grids**: Using CSS grid or flexbox, responsive designs employ fluid grids that automatically adjust the layout and positioning of elements based on the screen size. This allows the content to rearrange itself and fit different screen widths.

2. **Media Queries**: Media queries are CSS rules that apply different styles based on the characteristics of the device, such as screen width, height, and orientation. By defining breakpoints at specific screen sizes, developers can adapt the design and optimize the user experience for each device category.

3. **Flexible Images and Media**: Responsive design ensures that images and media elements, such as videos or embedded content, scale and adapt to fit different screen sizes. This prevents content from overflowing or becoming too small to view.

4. **Responsive Typography**: Typography is adjusted based on the screen size to ensure readability and legibility. Font sizes, line heights, and spacing are modified to provide an optimal reading experience on various devices.

5. **Mobile-First Approach**: A mobile-first approach involves designing the website first for mobile devices and then progressively enhancing it for larger screens. This approach prioritizes the mobile experience and ensures that the website performs well on smaller devices.

Responsive design can be used in various scenarios:

1. **Multi-Device Compatibility**: Responsive design allows websites to be accessible and functional across a wide range of devices, from desktop computers to smartphones and everything in between.

2. **Improved User Experience**: By adapting the layout and content to different screen sizes, responsive design ensures that users can easily navigate and consume information on any device, leading to a better user experience.

3. **Simplified Maintenance**: Creating a single responsive website instead of multiple versions for different devices simplifies the maintenance process. Content updates, bug fixes, and feature enhancements can be applied universally, saving time and effort.

4. **Future-Proofing**: With the ever-increasing variety of devices and screen sizes, responsive design provides a flexible and future-proof solution. It allows websites to adapt to new devices and technologies without the need for major redesigns or separate development efforts.

Responsive design has become essential in today's digital landscape, where users access websites from various devices. It enables websites to provide a consistent and optimized experience regardless of the device, ensuring that content is accessible and visually appealing to all users.

````

## 算法题

- 请实现一个二分查找算法。
```javascript
//请在此作答
function binarySearch(array, target) {
  let low = 0;
  let high = array.length - 1;

  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    let midValue = array[mid];

    if (midValue === target) {
      return mid; // Target found, return the index
    } else if (midValue < target) {
      low = mid + 1; // Target is in the right half
    } else {
      high = mid - 1; // Target is in the left half
    }
  }

  return -1; // Target not found
}

// Usage example:
const numbers = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91];
const target = 16;

const result = binarySearch(numbers, target);
if (result !== -1) {
  console.log(`Target ${target} found at index ${result}`);
} else {
  console.log(`Target ${target} not found in the array`);
}

````

- 请实现一个链表的反转算法。
  ```javascript
  //请在此作答
  class Node {
    constructor(value) {
      this.value = value;
      this.next = null;
    }
  }
  ```

class LinkedList {
constructor() {
this.head = null;
}

addNode(value) {
const newNode = new Node(value);
if (!this.head) {
this.head = newNode;
} else {
let currentNode = this.head;
while (currentNode.next) {
currentNode = currentNode.next;
}
currentNode.next = newNode;
}
}

reverse() {
let prevNode = null;
let currentNode = this.head;
let nextNode = null;

    while (currentNode) {
      nextNode = currentNode.next;
      currentNode.next = prevNode;
      prevNode = currentNode;
      currentNode = nextNode;
    }

    this.head = prevNode;

}

printList() {
let currentNode = this.head;
let result = '';
while (currentNode) {
result += currentNode.value + ' ';
currentNode = currentNode.next;
}
console.log(result.trim());
}
}

// Example usage
const linkedList = new LinkedList();
linkedList.addNode(1);
linkedList.addNode(2);
linkedList.addNode(3);
linkedList.addNode(4);
linkedList.addNode(5);

console.log('Original list:');
linkedList.printList();

console.log('Reversed list:');
linkedList.reverse();
linkedList.printList();

```

```
